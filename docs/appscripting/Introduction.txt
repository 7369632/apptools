Application Scripting Framework
===============================

The Application Scripting Framework is a component of the Enthought Tool Suite
that provides developers with an API that allows traits based objects to be
made scriptable.  Operations on a scriptable object can be recorded in a
script and subsequently replayed.

The framework is completely configurable.  Alternate implementations of all
major components can be provided if necessary.


Framework Concepts
------------------

The following are the concepts supported by the framework.

- Scriptable Type

  A scriptable type is a sub-type of ``HasTraits`` that has scriptable methods
  and scriptable traits.  If a scriptable method is called, or a scriptable
  trait is set, then that action can be recorded in a script and subsequently
  replayed.

  If the ``__init__()`` method is scriptable then the creation of an object
  from the type can be recorded.

  Scriptable types can be explicitly defined or created dynamically from any
  sub-type of ``HasTraits``.

- Scriptable API

  The set of a scriptable type's scriptable methods and traits constitutes the
  type's scriptable API.

  The API can be defined explicitly using the ``scriptable`` decorator (for
  methods) or the ``Scriptable`` wrapper (for traits).

  For scriptable types that are created dynamically then the API can be
  defined in terms of one or more types or interfaces or an explicit list of
  method and trait names.  By default, all public methods and traits (ie.
  those whose name does not begin with an underscore) are part of the API.  It
  is also possible to then explicitly exclude a list of method and trait
  names.

- Scriptable Object

  A scriptable object is an instance of a scriptable type.

  Scriptable objects can be explicitly created by calling the scriptable type.
  Alternatively a non-scriptable object can be made scriptable dynamically.

- Script

  A script is a Python script and may be a recording or written from scratch.

  If the creation of scriptable objects can be recorded, then it may be
  possible for a recording to be run directly by the Python interpreter and
  independently of the application that made the recording.  Otherwise the
  application must run the script and first create any scriptable objects
  refered to in the script.

- Binding

  A script runs in a namespace which is, by default, empty.  If the scriptable
  objects refered to in a script are not created by the script (because their
  type's ``__init__()`` method isn't scriptable) then they must be created by
  the application and added to the namespace.  Adding an object to the
  namespace is called binding.

  Scriptable objects whose creation can be recorded will automatically bind
  themselves when they are created.

  It also possible to bind an object factory rather than the object itself.
  The factory will be called, and the object created, only if the object is
  needed by the script when it is run.  This is typically used by plugins.

  The name that an object is bound to need bear no relation to the object's
  name within the application.  Names may be dotted names (eg. ``aaa.bbb.ccc``)
  and appropriate objects representing the intermediate parts of such a name
  will be created automatically.

  An event is fired whenever an object is bound (or when a bound factory is
  invoked).  This allows other objects (eg. an embedded Python shell) to
  expose scriptable objects in other ways.

- Script Manager

  A script manager is responsible for the recording and subsequent playback of
  scripts.  An application has a single script manager instance which can be
  explicitly set or created automatically.


API Overview
------------

FIXME: The rest of this document should be ignored.

This section gives a brief overview of the various classes implemented in the
framework.  The complete API_ documentation is available as endo generated
HTML.

The example_ application demonstrates all the major features of the framework.


UndoManager
...........

The ``UndoManager`` class is the default implementation of the ``IUndoManager``
interface.

``active_stack``
    This trait is a reference to the currently active command stack and may be
    None.  Typically it is set when some sort of editor becomes active.

``active_stack_clean``
    This boolean trait reflects the clean state of the currently active
    command stack.  It is intended to support a "document modified" indicator
    in the GUI.  It is maintained by the undo manager.

``stack_updated``
    This event is fired when the index of a command stack is changed.  A
    reference to the stack is passed as an argument to the event and may not
    be the currently active stack.

``undo_name``
    This Unicode trait is the name of the command that can be undone, and will
    be empty if there is no such command.  It is maintained by the undo
    manager.

``redo_name``
    This Unicode trait is the name of the command that can be redone, and will
    be empty if there is no such command.  It is maintained by the undo
    manager.

``sequence_nr``
    This integer trait is the sequence number of the next command to be
    executed.  It is incremented immediately before a command's ``do()``
    method is called.  A particular sequence number identifies the state of
    all command stacks handled by the undo manager and allows those stacks to
    be set to the point they were at at a particular point in time.  In other
    words, the sequence number allows otherwise independent command stacks to
    be synchronised.

``recording``
    This boolean trait is set if recording to a script is in progress.  It is
    maintained by the undo manager.

``script``
    This Unicode trait is the text of the script currently being recorded, or
    the last recorded script if none is currently being recorded.

``script_updated``
    This event is fired when the recorded script changes.  A reference to the
    undo manager is passed as an argument to the event.

``undo()``
    This method calls the ``undo()`` method of the last command on the active
    command stack.

``redo()``
    This method calls the ``redo()`` method of the last undone command on the
    active command stack.

``begin_recording()``
    This method clears any existing recorded script and begins recording the
    new one.

``end_recording()``
    This method ends the current recording.

``clear_recording()``
    This method clears the current recorded script.


CommandStack
............

The ``CommandStack`` class is the default implementation of the
``ICommandStack`` interface.

``clean``
    This boolean traits reflects the clean state of the command stack.  Its
    value changes as commands are executed, undone and redone.  It may also be
    explicitly set to mark the current stack position as being clean (when
    data is saved to disk for example).

``undo_name``
    This Unicode trait is the name of the command that can be undone, and will
    be empty if there is no such command.  It is maintained by the command
    stack.

``redo_name``
    This Unicode trait is the name of the command that can be redone, and will
    be empty if there is no such command.  It is maintained by the command
    stack.

``undo_manager``
    This trait is a reference to the undo manager that manages the command
    stack.

``push(command)``
    This method executes the given command by calling its ``do()`` method.
    Any value returned by ``do()`` is returned by ``push()``.  If the command
    couldn't be merged with the previous one then it is saved on the command
    stack.

``undo(sequence_nr=0)``
    This method undoes the last command.  If a sequence number is given then
    all commands are undone up to an including the sequence number.

``redo(sequence_nr=0)``
    This method redoes the last command and returns any result.  If a sequence
    number is given then all commands are redone up to an including the
    sequence number and any result of the last of these is returned.

``clear()``
    This method clears the command stack, without undoing or redoing any
    commands, and leaves the stack in a clean state.  It is typically used
    when all changes to the data have been abandoned.

``begin_macro(name)``
    This method begins a macro by creating an empty command with the given
    name.  The commands passed to all subsequent calls to ``push()`` will be
    contained in the macro until the next call to ``end_macro()``.  Macros may
    be nested.  The command stack is disabled (ie. nothing can be undone or
    redone) while a macro is being created (ie. while there is an outstanding
    ``end_macro()`` call).

``end_macro()``
    This method ends the current macro.


ICommand
........

The ``ICommand`` interface defines the interface that must be implemented by
any undoable/redoable command.

``data``
    This optional trait is a reference to the data object that the command
    operates on.  It is not used by the framework itself.

``name``
    This Unicode trait is the name of the command as it will appear in any GUI
    element (e.g. in the text of an undo and redo menu entry).  It may include
    ``&`` to indicate a keyboard shortcut which will be automatically removed
    whenever it is inappropriate.

``undoable``
    This boolean trait is set if the command is undoable.

``__init__(*args)``
    If the command takes arguments then the command must ensure that deep
    copies should be made if appropriate.

``do()``
    This method is called by a command stack to execute the command and to
    return any result.  The command must save any state necessary for the
    ``undo()`` and ``redo()`` methods to work.  It is guaranteed that this
    will only ever be called once and that it will be called before any call
    to ``undo()`` or ``redo()``.

``undo()``
    This method is called by a command stack to undo the command.

``redo()``
    This method is called by a command stack to redo the command.  Any
    returned value will replace the value that the command stack references
    from the original call to ``do()`` or previous call to ``redo()``.
    **FIXME:** Check this - why save any result if commands aren't scripted?

``merge(other)``
    This method is called by the command stack to try and merge the ``other``
    command with this one.  True should be returned if the commands were
    merged.  If the commands are merged then ``other`` will not be placed on
    the command stack.  A subsequent undo or redo of this modified command
    must have the same effect as the two original commands.


AbstractCommand
...............

``AbstractCommand`` is an abstract base class that implements the ``ICommand``
interface.  It provides a default value for the ``undoable`` trait and a
default implementation of the ``merge()`` method.


ScriptableObject
................

The ``ScriptableObject`` class is a ``HasTraits`` sub-class for any class that
has scriptable traits or methods.


Scriptable
..........

The ``Scriptable`` factory function creates a wrapper for a trait so that
changes to the value of the trait can be recorded.

Simple reads of the trait will not be recorded unless unless the value read is
bound to another scriptable trait or passed as an argument to a scriptable
method.  Passing ``has_side_effects=True`` ensures that a read will always be
recorded.


scriptable
..........

The ``scriptable`` decorator is applied to methods of objects that sub-class
``ScriptableObject`` so that calls to the method can be recorded.


CommandAction
.............

The ``CommandAction`` class is a sub-class of the PyFace ``Action`` class that
is used to wrap undo/redo commands.

``command``
    This callable trait must be set to a factory that will return an object
    that implements ``ICommand``.  It will be called when the action is invoked
    and the object created pushed onto the command stack.

``command_stack``
    This instance trait must be set to the command stack that commands invoked
    by the action are pushed to.

``data``
    This optional trait is a reference to the data object that will be passed
    to the ``command`` factory when it is called.


UndoAction
..........

The ``UndoAction`` class is a canned PyFace action that undoes the last
command of the active command stack.


RedoAction
..........

The ``RedoAction`` class is a canned PyFace action that redoes the last
command undone of the active command stack.


BeginRecordingAction
....................

The ``BeginRecordingAction`` class is a canned PyFace action that starts the
recording of changes to scriptable objects to a script.


EndRecordingAction
..................

The ``EndRecordingAction`` class is a canned PyFace action that ends the
recording of changes to scriptable objects to a script.


ClearRecordingAction
....................

The ``ClearRecordingAction`` class is a canned PyFace action that clears the
current recorded script.


.. _API: api/index.html
.. _example: https://svn.enthought.com/enthought/browser/AppTools/trunk/examples/undo/
